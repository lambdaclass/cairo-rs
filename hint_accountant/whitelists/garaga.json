{
    "allowed_reference_expressions_for_hint": [
        {
            "allowed_expressions": [],
            "hint_lines": [
                "BASE=ids.BASE",
                "assert 1 < ids.N_LIMBS <= 12",
                "p, sum_limbs = 0, []",
                "for i in range(ids.N_LIMBS):",
                "    p+=getattr(ids, 'P'+str(i)) * BASE**i",
                "p_limbs = [getattr(ids, 'P'+str(i)) for i in range(ids.N_LIMBS)]",
                "sum_limbs = [getattr(getattr(ids, 'a'), 'd'+str(i)) + getattr(getattr(ids, 'b'), 'd'+str(i)) for i in range(ids.N_LIMBS)]",
                "sum_unreduced = sum([sum_limbs[i] * BASE**i for i in range(ids.N_LIMBS)])",
                "sum_reduced = [sum_limbs[i] - p_limbs[i] for i in range(ids.N_LIMBS)]",
                "has_carry = [1 if sum_limbs[0] >= BASE else 0]",
                "for i in range(1,ids.N_LIMBS):",
                "    if sum_limbs[i] + has_carry[i-1] >= BASE:",
                "        has_carry.append(1)",
                "    else:",
                "        has_carry.append(0)",
                "needs_reduction = 1 if sum_unreduced >= p else 0",
                "has_borrow_carry_reduced = [-1 if sum_reduced[0] < 0 else (1 if sum_reduced[0]>=BASE else 0)]",
                "for i in range(1,ids.N_LIMBS):",
                "    if (sum_reduced[i] + has_borrow_carry_reduced[i-1]) < 0:",
                "        has_borrow_carry_reduced.append(-1)",
                "    elif (sum_reduced[i] + has_borrow_carry_reduced[i-1]) >= BASE:",
                "        has_borrow_carry_reduced.append(1)",
                "    else:",
                "        has_borrow_carry_reduced.append(0)",
                "memory[ap] = needs_reduction",
                "for i in range(ids.N_LIMBS-1):",
                "    if needs_reduction:",
                "        memory[ap+1+i] = has_borrow_carry_reduced[i]",
                "    else:",
                "        memory[ap+1+i] = has_carry[i]"
            ]
        },
        {
            "allowed_expressions": [],
            "hint_lines": [
                "BASE = ids.BASE",
                "assert 1 < ids.N_LIMBS <= 12",
                "p, sub_limbs = 0, []",
                "for i in range(ids.N_LIMBS):",
                "    p+=getattr(ids, 'P'+str(i)) * BASE**i",
                "p_limbs = [getattr(ids, 'P'+str(i)) for i in range(ids.N_LIMBS)]",
                "sub_limbs = [getattr(getattr(ids, 'a'), 'd'+str(i)) - getattr(getattr(ids, 'b'), 'd'+str(i)) for i in range(ids.N_LIMBS)]",
                "sub_unreduced = sum([sub_limbs[i] * BASE**i for i in range(ids.N_LIMBS)])",
                "sub_reduced = [sub_limbs[i] + p_limbs[i] for i in range(ids.N_LIMBS)]",
                "has_borrow = [-1 if sub_limbs[0] < 0 else 0]",
                "for i in range(1,ids.N_LIMBS):",
                "    if sub_limbs[i] + has_borrow[i-1] < 0:",
                "        has_borrow.append(-1)",
                "    else:",
                "        has_borrow.append(0)",
                "needs_reduction = 1 if sub_unreduced < 0 else 0",
                "has_borrow_carry_reduced = [-1 if sub_reduced[0] < 0 else (1 if sub_reduced[0]>=BASE else 0)]",
                "for i in range(1,ids.N_LIMBS):",
                "    if (sub_reduced[i] + has_borrow_carry_reduced[i-1]) < 0:",
                "        has_borrow_carry_reduced.append(-1)",
                "    elif (sub_reduced[i] + has_borrow_carry_reduced[i-1]) >= BASE:",
                "        has_borrow_carry_reduced.append(1)",
                "    else:",
                "        has_borrow_carry_reduced.append(0)",
                "memory[ap] = needs_reduction",
                "for i in range(ids.N_LIMBS-1):",
                "    if needs_reduction:",
                "        memory[ap+1+i] = has_borrow_carry_reduced[i]",
                "    else:",
                "        memory[ap+1+i] = has_borrow[i]"
            ]
        },
        {
            "allowed_expressions": [],
            "hint_lines": [
                "BASE = ids.BASE",
                "assert 1 < ids.N_LIMBS <= 12",
                "assert ids.DEGREE == ids.N_LIMBS-1",
                "a,b,p=0,0,0",
                "a_limbs, b_limbs, p_limbs = ids.N_LIMBS*[0], ids.N_LIMBS*[0], ids.N_LIMBS*[0]",
                "def split(x, degree=ids.DEGREE, base=ids.BASE):",
                "    coeffs = []",
                "    for n in range(degree, 0, -1):",
                "        q, r = divmod(x, base ** n)",
                "        coeffs.append(q)",
                "        x = r",
                "    coeffs.append(x)",
                "    return coeffs[::-1]",
                "def poly_mul(a:list, b:list,n=ids.N_LIMBS) -> list:",
                "    assert len(a) == len(b) == n",
                "    result = [0] * ids.N_LIMBS_UNREDUCED",
                "    for i in range(n):",
                "        for j in range(n):",
                "            result[i+j] += a[i]*b[j]",
                "    return result",
                "def poly_mul_plus_c(a:list, b:list, c:list, n=ids.N_LIMBS) -> list:",
                "    assert len(a) == len(b) == n",
                "    result = [0] * ids.N_LIMBS_UNREDUCED",
                "    for i in range(n):",
                "        for j in range(n):",
                "            result[i+j] += a[i]*b[j]",
                "    for i in range(n):",
                "        result[i] += c[i]",
                "    return result",
                "def poly_sub(a:list, b:list, n=ids.N_LIMBS_UNREDUCED) -> list:",
                "    assert len(a) == len(b) == n",
                "    result = [0] * n",
                "    for i in range(n):",
                "        result[i] = a[i] - b[i]",
                "    return result",
                "def abs_poly(x:list):",
                "    result = [0] * len(x)",
                "    for i in range(len(x)):",
                "        result[i] = abs(x[i])",
                "    return result",
                "def reduce_zero_poly(x:list):",
                "    x = x.copy()",
                "    carries = [0] * (len(x)-1)",
                "    for i in range(0, len(x)-1):",
                "        carries[i] = x[i] // ids.BASE",
                "        x[i] = x[i] % ids.BASE",
                "        assert x[i] == 0",
                "        x[i+1] += carries[i]",
                "    assert x[-1] == 0",
                "    return x, carries",
                "for i in range(ids.N_LIMBS):",
                "    a+=as_int(getattr(ids.a, 'd'+str(i)),PRIME) * ids.BASE**i",
                "    b+=as_int(getattr(ids.b, 'd'+str(i)),PRIME) * ids.BASE**i",
                "    p+=getattr(ids, 'P'+str(i)) * ids.BASE**i",
                "    a_limbs[i]=as_int(getattr(ids.a, 'd'+str(i)),PRIME)",
                "    b_limbs[i]=as_int(getattr(ids.b, 'd'+str(i)),PRIME)",
                "    p_limbs[i]=getattr(ids, 'P'+str(i))",
                "mul = a*b",
                "q, r = divmod(mul, p)",
                "qs, rs = split(q), split(r)",
                "for i in range(ids.N_LIMBS):",
                "    setattr(ids.r, 'd'+str(i), rs[i])",
                "    setattr(ids.q, 'd'+str(i), qs[i])",
                "val_limbs = poly_mul(a_limbs, b_limbs)",
                "q_P_plus_r_limbs = poly_mul_plus_c(qs, p_limbs, rs)",
                "diff_limbs = poly_sub(q_P_plus_r_limbs, val_limbs)",
                "_, carries = reduce_zero_poly(diff_limbs)",
                "carries = abs_poly(carries)",
                "for i in range(ids.N_LIMBS_UNREDUCED-1):",
                "    setattr(ids, 'flag'+str(i), 1 if diff_limbs[i] >= 0 else 0)",
                "    setattr(ids, 'q'+str(i), carries[i])"
            ]
        },
        {
            "allowed_expressions": [],
            "hint_lines": [
                "BASE = ids.BASE",
                "assert 1 < ids.N_LIMBS <= 12",
                "assert ids.DEGREE == ids.N_LIMBS-1",
                "a,p=0,0",
                "a_limbs, p_limbs = ids.N_LIMBS*[0], ids.N_LIMBS*[0]",
                "def split(x, degree=ids.DEGREE, base=ids.BASE):",
                "    coeffs = []",
                "    for n in range(degree, 0, -1):",
                "        q, r = divmod(x, base ** n)",
                "        coeffs.append(q)",
                "        x = r",
                "    coeffs.append(x)",
                "    return coeffs[::-1]",
                "def poly_sub(a:list, b:list, n=ids.N_LIMBS_UNREDUCED) -> list:",
                "    assert len(a) == len(b) == n",
                "    result = [0] * n",
                "    for i in range(n):",
                "        result[i] = a[i] - b[i]",
                "    return result",
                "def abs_poly(x:list):",
                "    result = [0] * len(x)",
                "    for i in range(len(x)):",
                "        result[i] = abs(x[i])",
                "    return result",
                "def reduce_zero_poly(x:list):",
                "    x = x.copy()",
                "    carries = [0] * (len(x)-1)",
                "    for i in range(0, len(x)-1):",
                "        carries[i] = x[i] // ids.BASE",
                "        x[i] = x[i] % ids.BASE",
                "        assert x[i] == 0",
                "        x[i+1] += carries[i]",
                "    assert x[-1] == 0",
                "    return x, carries",
                "for i in range(ids.N_LIMBS):",
                "    a+=as_int(getattr(ids.a, 'd'+str(i)),PRIME) * ids.BASE**i",
                "    p+=getattr(ids, 'P'+str(i)) * ids.BASE**i",
                "    a_limbs[i]=as_int(getattr(ids.a, 'd'+str(i)),PRIME)",
                "    p_limbs[i]=getattr(ids, 'P'+str(i))",
                "mul = a*9",
                "q, r = divmod(mul, p)",
                "rs = split(r)",
                "for i in range(ids.N_LIMBS):",
                "    setattr(ids.r, 'd'+str(i), rs[i])",
                "ids.q=q",
                "val_limbs = [a_limbs[i] * 9 for i in range(ids.N_LIMBS)]",
                "q_P_plus_r_limbs = [q * p_limbs[i] + rs[i] for i in range(ids.N_LIMBS)]",
                "diff_limbs = poly_sub(q_P_plus_r_limbs, val_limbs, ids.N_LIMBS)",
                "_, carries = reduce_zero_poly(diff_limbs)",
                "carries = abs_poly(carries)",
                "for i in range(ids.N_LIMBS-1):",
                "    setattr(ids, 'flag'+str(i), 1 if diff_limbs[i] >= 0 else 0)",
                "    setattr(ids, 'q'+str(i), carries[i])"
            ]
        },
        {
            "allowed_expressions": [],
            "hint_lines": [
                "BASE = ids.BASE",
                "assert 1 < ids.N_LIMBS <= 12",
                "assert ids.DEGREE == ids.N_LIMBS-1",
                "a,p=0,0",
                "a_limbs, p_limbs = ids.N_LIMBS*[0], ids.N_LIMBS*[0]",
                "def split(x, degree=ids.DEGREE, base=ids.BASE):",
                "    coeffs = []",
                "    for n in range(degree, 0, -1):",
                "        q, r = divmod(x, base ** n)",
                "        coeffs.append(q)",
                "        x = r",
                "    coeffs.append(x)",
                "    return coeffs[::-1]",
                "def poly_sub(a:list, b:list, n=ids.N_LIMBS_UNREDUCED) -> list:",
                "    assert len(a) == len(b) == n",
                "    result = [0] * n",
                "    for i in range(n):",
                "        result[i] = a[i] - b[i]",
                "    return result",
                "def abs_poly(x:list):",
                "    result = [0] * len(x)",
                "    for i in range(len(x)):",
                "        result[i] = abs(x[i])",
                "    return result",
                "def reduce_zero_poly(x:list):",
                "    x = x.copy()",
                "    carries = [0] * (len(x)-1)",
                "    for i in range(0, len(x)-1):",
                "        carries[i] = x[i] // ids.BASE",
                "        x[i] = x[i] % ids.BASE",
                "        assert x[i] == 0",
                "        x[i+1] += carries[i]",
                "    assert x[-1] == 0",
                "    return x, carries",
                "for i in range(ids.N_LIMBS):",
                "    a+=as_int(getattr(ids.a, 'd'+str(i)),PRIME) * ids.BASE**i",
                "    p+=getattr(ids, 'P'+str(i)) * ids.BASE**i",
                "    a_limbs[i]=as_int(getattr(ids.a, 'd'+str(i)),PRIME)",
                "    p_limbs[i]=getattr(ids, 'P'+str(i))",
                "mul = a*10",
                "q, r = divmod(mul, p)",
                "rs = split(r)",
                "for i in range(ids.N_LIMBS):",
                "    setattr(ids.r, 'd'+str(i), rs[i])",
                "ids.q=q",
                "val_limbs = [a_limbs[i] * 10 for i in range(ids.N_LIMBS)]",
                "q_P_plus_r_limbs = [q * p_limbs[i] + rs[i] for i in range(ids.N_LIMBS)]",
                "diff_limbs = poly_sub(q_P_plus_r_limbs, val_limbs, ids.N_LIMBS)",
                "_, carries = reduce_zero_poly(diff_limbs)",
                "carries = abs_poly(carries)",
                "for i in range(ids.N_LIMBS-1):",
                "    setattr(ids, 'flag'+str(i), 1 if diff_limbs[i] >= 0 else 0)",
                "    setattr(ids, 'q'+str(i), carries[i])"
            ]
        },
        {
            "allowed_expressions": [],
            "hint_lines": [
                "BASE = ids.BASE",
                "assert 1 < ids.N_LIMBS <= 12",
                "assert ids.DEGREE == ids.N_LIMBS-1",
                "a,p=0,0",
                "a_limbs, p_limbs = ids.N_LIMBS*[0], ids.N_LIMBS*[0]",
                "def split(x, degree=ids.DEGREE, base=ids.BASE):",
                "    coeffs = []",
                "    for n in range(degree, 0, -1):",
                "        q, r = divmod(x, base ** n)",
                "        coeffs.append(q)",
                "        x = r",
                "    coeffs.append(x)",
                "    return coeffs[::-1]",
                "for i in range(ids.N_LIMBS):",
                "    a+=as_int(getattr(ids.a, 'd'+str(i)),PRIME) * ids.BASE**i",
                "    p+=getattr(ids, 'P'+str(i)) * ids.BASE**i",
                "    a_limbs[i]=as_int(getattr(ids.a, 'd'+str(i)),PRIME)",
                "    p_limbs[i]=getattr(ids, 'P'+str(i))",
                "inv = pow(a, -1, p)",
                "invs = split(inv)",
                "for i in range(ids.N_LIMBS):",
                "    setattr(ids.inv, 'd'+str(i), invs[i])"
            ]
        },
        {
            "allowed_expressions": [],
            "hint_lines": [
                "from starkware.cairo.common.math_utils import as_int",
                "assert 1 < ids.N_LIMBS <= 12",
                "assert ids.DEGREE == ids.N_LIMBS-1",
                "a0,a1,p=0,0,0",
                "def split(x, degree=ids.DEGREE, base=ids.BASE):",
                "    coeffs = []",
                "    for n in range(degree, 0, -1):",
                "        q, r = divmod(x, base ** n)",
                "        coeffs.append(q)",
                "        x = r",
                "    coeffs.append(x)",
                "    return coeffs[::-1]",
                "for i in range(ids.N_LIMBS):",
                "    a0+=as_int(getattr(ids.x.a0, 'd'+str(i)), PRIME) * ids.BASE**i",
                "    a1+=as_int(getattr(ids.x.a1, 'd'+str(i)), PRIME) * ids.BASE**i",
                "    p+=getattr(ids, 'P'+str(i)) * ids.BASE**i",
                "def inv_e2(a0:int, a1:int):",
                "    t0, t1 = (a0 * a0 % p, a1 * a1 % p)",
                "    t0 = (t0 + t1) % p",
                "    t1 = pow(t0, -1, p)",
                "    return (a0 * t1 % p, -(a1 * t1) % p)",
                "inverse0, inverse1 = inv_e2(a0, a1)",
                "inv0, inv1 =split(inverse0), split(inverse1)",
                "for i in range(ids.N_LIMBS):",
                "    setattr(ids.inv0, 'd'+str(i),  inv0[i])",
                "    setattr(ids.inv1, 'd'+str(i),  inv1[i])"
            ]
        },
        {
            "allowed_expressions": [],
            "hint_lines": [
                "from starkware.cairo.common.math_utils import as_int",
                "assert 1 < ids.N_LIMBS <= 12",
                "p, c0, c1=0, 6*[0], 6*[0]",
                "c0_refs =[ids.x.c0.b0.a0, ids.x.c0.b0.a1, ids.x.c0.b1.a0, ids.x.c0.b1.a1, ids.x.c0.b2.a0, ids.x.c0.b2.a1]",
                "c1_refs =[ids.x.c1.b0.a0, ids.x.c1.b0.a1, ids.x.c1.b1.a0, ids.x.c1.b1.a1, ids.x.c1.b2.a0, ids.x.c1.b2.a1]",
                "// E2 Tower:",
                "def mul_e2(x:(int,int), y:(int,int)):",
                "    a = (x[0] + x[1]) * (y[0] + y[1]) % p",
                "    b, c  = x[0]*y[0] % p, x[1]*y[1] % p",
                "    return (b - c) % p, (a - b - c) % p",
                "def square_e2(x:(int,int)):",
                "    return mul_e2(x,x)",
                "def double_e2(x:(int,int)):",
                "    return 2*x[0]%p, 2*x[1]%p",
                "def sub_e2(x:(int,int), y:(int,int)):",
                "    return (x[0]-y[0]) % p, (x[1]-y[1]) % p",
                "def neg_e2(x:(int,int)):",
                "    return -x[0] % p, -x[1] % p",
                "def mul_by_non_residue_e2(x:(int, int)):",
                "    return mul_e2(x, (ids.NON_RESIDUE_E2_a0, ids.NON_RESIDUE_E2_a1))",
                "def add_e2(x:(int,int), y:(int,int)):",
                "    return (x[0]+y[0]) % p, (x[1]+y[1]) % p",
                "def inv_e2(a:(int, int)):",
                "    t0, t1 = (a[0] * a[0] % p, a[1] * a[1] % p)",
                "    t0 = (t0 + t1) % p",
                "    t1 = pow(t0, -1, p)",
                "    return a[0] * t1 % p, -(a[1] * t1) % p",
                "// E6 Tower:",
                "def mul_by_non_residue_e6(x:((int,int),(int,int),(int,int))):",
                "    return mul_by_non_residue_e2(x[2]), x[0], x[1]",
                "def sub_e6(x:((int,int), (int,int), (int,int)),y:((int,int), (int,int), (int,int))):",
                "    return (sub_e2(x[0], y[0]), sub_e2(x[1], y[1]), sub_e2(x[2], y[2]))",
                "def neg_e6(x:((int,int), (int,int), (int,int))):",
                "    return neg_e2(x[0]), neg_e2(x[1]), neg_e2(x[2])",
                "def inv_e6(x:((int,int),(int,int),(int,int))):",
                "    t0, t1, t2 = square_e2(x[0]), square_e2(x[1]), square_e2(x[2])",
                "    t3, t4, t5 = mul_e2(x[0], x[1]), mul_e2(x[0], x[2]), mul_e2(x[1], x[2]) ",
                "    c0 = add_e2(neg_e2(mul_by_non_residue_e2(t5)), t0)",
                "    c1 = sub_e2(mul_by_non_residue_e2(t2), t3)",
                "    c2 = sub_e2(t1, t4)",
                "    t6 = mul_e2(x[0], c0)",
                "    d1 = mul_e2(x[2], c1)",
                "    d2 = mul_e2(x[1], c2)",
                "    d1 = mul_by_non_residue_e2(add_e2(d1, d2))",
                "    t6 = add_e2(t6, d1)",
                "    t6 = inv_e2(t6)",
                "    return mul_e2(c0, t6), mul_e2(c1, t6), mul_e2(c2, t6)",
                "def mul_e6(x:((int,int),(int,int),(int,int)), y:((int,int),(int,int),(int,int))):",
                "    assert len(x) == 3 and len(y) == 3 and len(x[0]) == 2 and len(x[1]) == 2 and len(x[2]) == 2 and len(y[0]) == 2 and len(y[1]) == 2 and len(y[2]) == 2",
                "    t0, t1, t2 = mul_e2(x[0], y[0]), mul_e2(x[1], y[1]), mul_e2(x[2], y[2])",
                "    c0 = add_e2(x[1], x[2])",
                "    tmp = add_e2(y[1], y[2])",
                "    c0 = mul_e2(c0, tmp)",
                "    c0 = sub_e2(c0, t1)",
                "    c0 = sub_e2(c0, t2)",
                "    c0 = mul_by_non_residue_e2(c0)",
                "    c0 = add_e2(c0, t0)",
                "    c1 = add_e2(x[0], x[1])",
                "    tmp = add_e2(y[0], y[1])",
                "    c1 = mul_e2(c1, tmp)",
                "    c1 = sub_e2(c1, t0)",
                "    c1 = sub_e2(c1, t1)",
                "    tmp = mul_by_non_residue_e2(t2)",
                "    c1 = add_e2(c1, tmp)",
                "    tmp = add_e2(x[0], x[2])",
                "    c2 = add_e2(y[0], y[2])",
                "    c2 = mul_e2(c2, tmp)",
                "    c2 = sub_e2(c2, t0)",
                "    c2 = sub_e2(c2, t2)",
                "    c2 = add_e2(c2, t1)",
                "    return c0, c1, c2",
                "def square_e6(x:((int,int),(int,int),(int,int))):",
                "    return mul_e6(x,x)",
                "def inv_e12(c0:((int,int),(int,int),(int,int)), c1:((int,int),(int,int),(int,int))):",
                "    t0, t1 = square_e6(c0), square_e6(c1)",
                "    tmp = mul_by_non_residue_e6(t1)",
                "    t0 = sub_e6(t0, tmp)",
                "    t1 = inv_e6(t0)",
                "    c0 = mul_e6(c0, t1)",
                "    c1 = mul_e6(c1, t1)",
                "    c1 = neg_e6(c1)",
                "    return [c0[0][0], c0[0][1], c0[1][0], c0[1][1], c0[2][0], c0[2][1], c1[0][0], c1[0][1], c1[1][0], c1[1][1], c1[2][0], c1[2][1]]",
                "for i in range(ids.N_LIMBS):",
                "    for k in range(6):",
                "        c0[k]+=as_int(getattr(c0_refs[k], 'd'+str(i)), PRIME) * ids.BASE**i",
                "        c1[k]+=as_int(getattr(c1_refs[k], 'd'+str(i)), PRIME) * ids.BASE**i",
                "    p+=getattr(ids, 'P'+str(i)) * ids.BASE**i",
                "c0 = ((c0[0],c0[1]),(c0[2],c0[3]),(c0[4],c0[5]))",
                "c1 = ((c1[0],c1[1]),(c1[2],c1[3]),(c1[4],c1[5]))",
                "x_inv = inv_e12(c0,c1)",
                "e = [split(x) for x in x_inv]",
                "for i in range(12):",
                "    for l in range(ids.N_LIMBS):",
                "        setattr(getattr(ids,f\"inv{i}\"),f\"d{l}\",e[i][l])"
            ]
        }
    ]
}