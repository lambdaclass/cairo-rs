use std::collections::HashMap;

use felt::Felt252;
use num_traits::{One, Zero, Num};
#[cfg(target_arch = "wasm32")]
use wasm_bindgen_test::*;

use crate::{
    cairo_run::{cairo_run, CairoRunConfig},
    hint_processor::{
        builtin_hint_processor::{
            builtin_hint_processor_definition::{BuiltinHintProcessor, HintProcessorData},
            hint_utils::insert_value_from_var_name,
        },
        hint_processor_definition::{HintExtension, HintProcessorLogic, HintReference},
    },
    serde::deserialize_program::ApTracking,
    vm::{
        errors::hint_errors::HintError,
        runners::cairo_runner::{ResourceTracker, RunResources},
        vm_core::VirtualMachine,
    },
};

struct SimplifiedOsHintProcessor {
    builtin_hint_processor: BuiltinHintProcessor,
    run_resources: RunResources,
}

impl ResourceTracker for SimplifiedOsHintProcessor {
    fn consumed(&self) -> bool {
        self.run_resources.consumed()
    }

    fn consume_step(&mut self) {
        self.run_resources.consume_step()
    }

    fn get_n_steps(&self) -> Option<usize> {
        self.run_resources.get_n_steps()
    }

    fn run_resources(&self) -> &RunResources {
        &self.run_resources
    }
}

impl Default for SimplifiedOsHintProcessor {
    fn default() -> Self {
        Self {
            builtin_hint_processor: BuiltinHintProcessor::new_empty(),
            run_resources: Default::default(),
        }
    }
}

impl HintProcessorLogic for SimplifiedOsHintProcessor {
    fn execute_hint(
        &mut self,
        _vm: &mut crate::vm::vm_core::VirtualMachine,
        _exec_scopes: &mut crate::types::exec_scope::ExecutionScopes,
        //Data structure that can be downcasted to the structure generated by compile_hint
        _hint_data: &Box<dyn core::any::Any>,
        //Constant values extracted from the program specification.
        _constants: &std::collections::HashMap<String, felt::Felt252>,
    ) -> Result<(), crate::vm::errors::hint_errors::HintError> {
        // Empty impl as we are using `execute_hint_extensive` instead for this case
        Ok(())
    }

    fn execute_hint_extensive(
        &mut self,
        vm: &mut crate::vm::vm_core::VirtualMachine,
        exec_scopes: &mut crate::types::exec_scope::ExecutionScopes,
        //Data structure that can be downcasted to the structure generated by compile_hint
        hint_data: &Box<dyn core::any::Any>,
        //Constant values extracted from the program specification.
        constants: &std::collections::HashMap<String, felt::Felt252>,
    ) -> Result<
        crate::hint_processor::hint_processor_definition::HintExtension,
        crate::vm::errors::hint_errors::HintError,
    > {
        // First attempt to execute with builtin hint processor
        match self.builtin_hint_processor.execute_hint_extensive(
            vm,
            exec_scopes,
            hint_data,
            constants,
        ) {
            Err(HintError::UnknownHint(_)) => {}
            res => return res,
        }
        // Execute os-specific hints
        let hint_data = hint_data
            .downcast_ref::<HintProcessorData>()
            .ok_or(HintError::WrongHintData)?;
        match &*hint_data.code {
            ALLOC_FACTS => alloc_facts(vm, &hint_data.ids_data, &hint_data.ap_tracking),
            COMPILE_CLASS => compile_class(vm, &hint_data.ids_data, &hint_data.ap_tracking),
            VM_LOAD_PROGRAM => vm_load_program(vm, &hint_data.ids_data, &hint_data.ap_tracking),
            code => Err(HintError::UnknownHint(code.to_string().into_boxed_str())),
        }
    }
}

// Hints & Hint impls
const ALLOC_FACTS: &str = "ids.compiled_class_facts = segments.add()";
pub fn alloc_facts(
    vm: &mut VirtualMachine,
    ids_data: &HashMap<String, HintReference>,
    ap_tracking: &ApTracking,
) -> Result<HintExtension, HintError> {
    insert_value_from_var_name(
        "compiled_class_facts",
        vm.add_memory_segment(),
        vm,
        ids_data,
        ap_tracking,
    )?;
    Ok(HintExtension::default())
}
const COMPILE_CLASS: &str = "from starkware.starknet.services.api.contract_class.contract_class import DeprecatedCompiledClass\nfrom starkware.starknet.core.os.contract_class.deprecated_class_hash import (\n    get_deprecated_contract_class_struct,\n)\nwith open(\"test_contract.json\", \"r\") as f:\n    compiled_class = DeprecatedCompiledClass.loads(f.read())\n \ncairo_contract = get_deprecated_contract_class_struct(\n    identifiers=ids._context.identifiers, contract_class=compiled_class)\nids.compiled_class = segments.gen_arg(cairo_contract)";
pub fn compile_class(
    vm: &mut VirtualMachine,
    ids_data: &HashMap<String, HintReference>,
    ap_tracking: &ApTracking,
) -> Result<HintExtension, HintError> {
    // We wil use a hardcoded constract to avoid importing starknet-related code for this test
    // What this hint does is to load the `ids.compiled_class` variable of type *DeprecatedCompiledClass with the compiled cairo contract "test_contract.json"
    // First we need to allocate the struct
    let compiled_class_ptr = vm.add_memory_segment();
    insert_value_from_var_name(
        "compiled_class",
        compiled_class_ptr,
        vm,
        ids_data,
        ap_tracking,
    )?;
    // Now we can fill each struct field with our hardcoded values
    let mut ptr = compiled_class_ptr;
    // For this test's purpose we will be using the following cairo 0 contract:
    // %lang starknet
    // @view
    // func get_number() -> (number: felt) {
    //     return (number=14);
    // }

    // struct DeprecatedCompiledClass {
    // compiled_class_version: felt,
    vm.insert_value(ptr, Felt252::default())?; // Not relevant
    ptr.offset += 1;

    // // The length and pointer to the external entry point table of the contract.
    // n_external_functions: felt,
    vm.insert_value(ptr, Felt252::one())?; // Only one external entrypoint
    ptr.offset += 1;
    // external_functions: DeprecatedContractEntryPoint*,
    let mut entrypoints_ptr = vm.add_memory_segment();
    // We only insert one entrypoint:
    // struct DeprecatedContractEntryPoint {
    //     // A field element that encodes the signature of the called function.
    //     selector: felt,
    let selector = Felt252::one(); //TODO
    vm.insert_value(entrypoints_ptr, selector)?;
    entrypoints_ptr.offset += 1;
    //     // The offset of the instruction that should be called within the contract bytecode.
    //     offset: felt,
    let offset = Felt252::one(); //TODO
    vm.insert_value(entrypoints_ptr, offset)?;
    // }
    vm.insert_value(ptr, entrypoints_ptr)?; // Only one external entrypoint
    ptr.offset += 1;
    // // The length and pointer to the L1 handler entry point table of the contract.
    // n_l1_handlers: felt,
    vm.insert_value(ptr, Felt252::zero())?;
    ptr.offset += 1;
    // l1_handlers: DeprecatedContractEntryPoint*,
    let l1_handler_entrypoints_ptr = vm.add_memory_segment();
    vm.insert_value(ptr, l1_handler_entrypoints_ptr)?;
    ptr.offset += 1;
    // // The length and pointer to the constructor entry point table of the contract.
    // n_constructors: felt,
    vm.insert_value(ptr, Felt252::zero())?;
    ptr.offset += 1;
    // constructors: DeprecatedContractEntryPoint*,
    let constructor_entrypoints_ptr = vm.add_memory_segment();
    vm.insert_value(ptr, constructor_entrypoints_ptr)?;
    ptr.offset += 1;

    // n_builtins: felt,
    vm.insert_value(ptr, Felt252::zero())?;
    ptr.offset += 1;
    // // 'builtin_list' is a continuous memory segment containing the ASCII encoding of the (ordered)
    // // builtins used by the program.
    // builtin_list: felt*,
    let builtins_ptr = vm.add_memory_segment();
    vm.insert_value(ptr, builtins_ptr)?;
    ptr.offset += 1;

    // The hinted_class_hash field should be set to the starknet_keccak of the
    // contract program, including its hints. However the OS does not validate that.
    // This field may be used by the operator to differentiate between contract classes that
    // differ only in the hints.
    // This field is included in the hash of the ContractClass to simplify the implementation.
    // hinted_class_hash: felt,
    vm.insert_value(ptr, Felt252::zero())?;
    ptr.offset += 1;

    // // The length and pointer of the bytecode.
    let byte_code = vec![
        Felt252::from_str_radix("480680017fff8000", 16).unwrap().into(),
        Felt252::from_str_radix("e", 16).unwrap().into(),
        Felt252::from_str_radix("208b7fff7fff7ffe", 16).unwrap().into(),
        Felt252::from_str_radix("40780017fff7fff", 16).unwrap().into(),
        Felt252::from_str_radix("1", 16).unwrap().into(),
        Felt252::from_str_radix("4003800080007ffc", 16).unwrap().into(),
        Felt252::from_str_radix("4826800180008000", 16).unwrap().into(),
        Felt252::from_str_radix("1", 16).unwrap().into(),
        Felt252::from_str_radix("480a7ffd7fff8000", 16).unwrap().into(),
        Felt252::from_str_radix("4828800080007ffe", 16).unwrap().into(),
        Felt252::from_str_radix("480a80007fff8000", 16).unwrap().into(),
        Felt252::from_str_radix("208b7fff7fff7ffe", 16).unwrap().into(),
        Felt252::from_str_radix("402b7ffd7ffc7ffd", 16).unwrap().into(),
        Felt252::from_str_radix("1104800180018000", 16).unwrap().into(),
        Felt252::from_str_radix("800000000000010fffffffffffffffffffffffffffffffffffffffffffffff4", 16).unwrap().into(),
        Felt252::from_str_radix("480280017ffb8000", 16).unwrap().into(),
        Felt252::from_str_radix("1104800180018000", 16).unwrap().into(),
        Felt252::from_str_radix("800000000000010fffffffffffffffffffffffffffffffffffffffffffffff4", 16).unwrap().into(),
        Felt252::from_str_radix("480280007ffb8000", 16).unwrap().into(),
        Felt252::from_str_radix("48127ffc7fff8000", 16).unwrap().into(),
        Felt252::from_str_radix("48127ffc7fff8000", 16).unwrap().into(),
        Felt252::from_str_radix("48127ffc7fff8000", 16).unwrap().into(),
        Felt252::from_str_radix("208b7fff7fff7ffe", 16).unwrap().into(),
    ];
    // bytecode_length: felt,
    vm.insert_value(ptr, Felt252::from(byte_code.len()))?;
    ptr.offset += 1;
    // bytecode_ptr: felt*,
    let byte_code_ptr = vm.add_memory_segment();
    vm.load_data(byte_code_ptr, &byte_code)?;
    vm.insert_value(ptr, byte_code_ptr)?;
    //}

    Ok(HintExtension::default())
}

const VM_LOAD_PROGRAM: &str = "vm_load_program(compiled_class.program, ids.compiled_class.bytecode_ptr)";
pub fn vm_load_program(
    _vm: &mut VirtualMachine,
    _ids_data: &HashMap<String, HintReference>,
    _ap_tracking: &ApTracking,
) -> Result<HintExtension, HintError> {
    // TODO: Load Hints
    Ok(HintExtension::default())
}

#[test]
#[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
fn run_deprecated_cc() {
    let mut hint_processor = SimplifiedOsHintProcessor::default();
    let program_content =
        include_bytes!("../../../cairo_programs/noretrocompat/starknet_os_deprecated_cc.json");
    let _ = cairo_run(
        program_content,
        &CairoRunConfig::default(),
        &mut hint_processor,
    )
    .unwrap();
}
